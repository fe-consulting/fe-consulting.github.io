{"data":{"markdownRemark":{"html":"<p>While not the fastest, by default Angular is one of the most performant frameworks around.</p>\n<p>Even if the majority of applications will run just fine without having to make any advanced optimizations, running complex applications even on older browsers and slower devices can still be a daunting task.</p>\n<h2 id=\"changedetectionstrategy\"><a href=\"#changedetectionstrategy\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ChangeDetectionStrategy</h2>\n<p>The first and probably most important tweak we can do is changing the detection strategy Angular uses by default in order to minimize the amount of times the change detection will run, which will as a result make your app perform smoother and faster.</p>\n<p>By default, you guessed it, Angular uses the strategy <code class=\"language-text\">ChangeDetectionStrategy.Default</code>. This means that the component will be always checked.</p>\n<p>Why do that, if most components did not need to get updated? Enter <code class=\"language-text\">ChangeDetectionStrategy.OnPush</code>, which will instruct the change detection to skip a component except when any of the following situations happens:</p>\n<ul>\n<li>Input reference of the component changes</li>\n<li>DOM Event within a component has been dispatched</li>\n<li>Async events (HTTP, WebSocket, setTimeout/setInterval) within a component</li>\n<li>Emission of an observable event subscribed with Async pipe</li>\n<li>change detection is manually run</li>\n</ul>\n<p>This practice is even more important for large and complex applications as the amount of components skipped by the change detection is substantial.</p>\n<p>Developers coming from Angular 1.x may finding this confusing and difficult to use and admittedly using OnPush without leveraging RxJS is not always easy.\nWith that said, I like to argue that using OnPush offers a way for better coding practices. For example, by promoting the usage of RxJS and the async pipe, we get a predictable and declarative codebase which also happens to be super-performant.</p>\n<p>In short, RxJS + OnPush = win-win.</p>\n<p>There are two simple ways for making this easier. We can use the state management library NGRX, that leverages RxJS for selecting data from the store, and pretty much means that all the data held in components is an observable. Alternatively, we can keep our store in simple services and expose the data with observables.</p>\n<h3 id=\"use-ngrx\"><a href=\"#use-ngrx\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Use NGRX</h3>\n<p>If you don't know NGRX yet, then I recommend you give it a read. In order to read the following example, all you need to know is that we're retrieveing data from the store (think of it as our database) as an observable, and that we're displaying it in our template by subscribing via the <code class=\"language-text\">async</code> pipe.</p>\n<p>Component:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">@Component({\n    ...,\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class TodosComponent {\n    constructor(private store: Store&lt;AppState&gt;) {}\n\n    ngOnInit() {\n        this.todos$ = this.store.select((state) =&gt; state.todos);\n    }\n}</code></pre>\n      </div>\n<p>Template:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">&lt;div *ngFor=&quot;let todo of (todos$ | async)&quot;&gt;\n    {{ todo.name }}\n&lt;/div&gt;</code></pre>\n      </div>\n<p>The framework will render the template every time <code class=\"language-text\">todos$</code> emits a new value.</p>\n<h3 id=\"use-observables-and-subjects-with-async-pipe\"><a href=\"#use-observables-and-subjects-with-async-pipe\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Use Observables and Subjects with async pipe</h3>\n<p>The <code class=\"language-text\">async</code> pipe is not the most straightforward concept for people not used to working with RxJS, which is why I'd like to demistify it and show a few examples when it is particularly useful.</p>\n<p>The most obvious one that comes to mind is using the <code class=\"language-text\">async</code> pipe to render data coming from an HTTP call. Let's create a component that retrieves some data from an endpoint and it simply displays it on the page:</p>\n<p>Component:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">@Component({\n    ...,\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class TodosComponent {\n    constructor(private http: HttpClient) {}\n\n    ngOnInit() {\n        this.todos$ = this.http.get(&quot;/api/todos&quot;);\n    }\n}</code></pre>\n      </div>\n<p>Template:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">&lt;div *ngFor=&quot;let todo of (todos$ | async)&quot;&gt;\n    {{ todo.name }}\n&lt;/div&gt;</code></pre>\n      </div>\n<p>Advantages to using the <code class=\"language-text\">async</code> pipe:</p>\n<ul>\n<li>automatically subscribes to observables</li>\n<li>gets automatically unsubscribed for you by the framework</li>\n<li>effortlessly cooperation with ChangeStrategyStrategy.OnPush</li>\n</ul>","frontmatter":{"title":"Methods and practices for faster Angular apps - change detection","date":"14.04.2019","category":"angular"},"timeToRead":3}},"pageContext":{"slug":"/methods-and-practices-for-faster-angular-apps-change-detection","prev":null,"next":null}}