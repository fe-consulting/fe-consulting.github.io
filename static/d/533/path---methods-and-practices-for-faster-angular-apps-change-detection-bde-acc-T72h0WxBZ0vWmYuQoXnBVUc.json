{"data":{"markdownRemark":{"html":"<p>While not the fastest, by default Angular is one of the most performant frameworks around.</p>\n<p>Even if the majority of applications will run just fine without having to make any advanced optimizations, running complex applications even on older browsers and slower devices can still be a daunting task.</p>\n<h2 id=\"changedetectionstrategy-\"><a href=\"#changedetectionstrategy-\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ChangeDetectionStrategy ðŸ”¥</h2>\n<p>The first and probably most important tweak we can do is changing the detection strategy Angular uses by default in order to minimize the amount of times the change detection will run, which will as a result make your app perform smoother and faster.</p>\n<p>By default, you guessed it, Angular uses the strategy <code class=\"language-text\">ChangeDetectionStrategy.Default</code>. This means that the component will be always checked.</p>\n<p>Why do that, if most components did not need to get updated? Enter <code class=\"language-text\">ChangeDetectionStrategy.OnPush</code>, which will instruct the change detection to skip a component except when any of the following situations happens:</p>\n<ul>\n<li>Input reference of the component changes</li>\n<li>DOM Event within a component has been dispatched (ex. click)</li>\n<li>Emission of an observable event subscribed with Async pipe</li>\n<li>change detection is manually run</li>\n</ul>\n<p>This practice is even more important for large and complex applications as the amount of components skipped by the change detection is substantial.</p>\n<p>In the following example, our component will <em>not</em> be updating the view:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">@Component({\n  ...,\n  template: &#39;{{ count }}&#39;,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ChangeDetectionComponent implements OnInit {\n  count = 0;\n\n  ngOnInit() {\n    setInterval(() =&gt; ++this.count, 1000);\n  }\n}</code></pre>\n      </div>\n<h3 id=\"rxjs-to-the-rescue\"><a href=\"#rxjs-to-the-rescue\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RxJS to the rescue</h3>\n<p>Developers coming from Angular 1.x may finding this confusing and difficult to use: admittedly, using OnPush without RxJS is not always easy.</p>\n<p>With that said, I like to argue that using OnPush offers a way for better coding practices. For example, by promoting the usage of RxJS and the <code class=\"language-text\">async</code> pipe, we get a predictable and declarative codebase which also happens to be super-performant.</p>\n<p>Here are some advantages to using the <code class=\"language-text\">async</code> pipe:</p>\n<ul>\n<li>automatically subscribes to observables</li>\n<li>automatically unsubscribes when the component gets destroyed</li>\n<li>effortless cooperation with ChangeStrategyStrategy.OnPush</li>\n<li>reduced LOC in our components</li>\n</ul>\n<p>In short, RxJS + OnPush = win-win.</p>\n<p>Let's refactor the previous example using an <code class=\"language-text\">Observable</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">@Component({\n  ...,\n  template: &#39;{{ count$ | async }}&#39;,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ChangeDetectionComponent implements OnInit {\n  count$: Observable&lt;number&gt;;\n\n  ngOnInit() {\n    this.count$ = interval(1000)\n        .pipe(\n            map((count: number) =&gt; ++count)\n        );\n  }\n}</code></pre>\n      </div>\n<p>We now have an elegant, declarative and performant solution!</p>\n<h3 id=\"ngrx\"><a href=\"#ngrx\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NGRX</h3>\n<p>When dealing with a large-scale application, I highly recommend to use a state-management library. Not only because it helps manage state, but also because Angular state management libraries treat Observables as first-class citizens, just like the framework does. While there's a bunch of great libraries out there, I highly recommend NGRX.</p>\n<p>NGRX makes working with pure Angular components effortlessly by using RxJS for pulling data from the store, which means all the data held in components are observables.</p>\n<p>If you don't know NGRX yet, then I recommend you give it a read.</p>\n<p>In order to read the following example, all you need to know is that we're retrieveing data from the store (think of it as our database) as an observable, and that we're displaying it in our template by subscribing via the <code class=\"language-text\">async</code> pipe.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">@Component({\n    ...,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: `\n        &lt;div *ngFor=&quot;let todo of (todos$ | async)&quot;&gt;\n            {{ todo.name }}\n        &lt;/div&gt;\n    `\n})\nexport class TodosComponent {\n    constructor(private store: Store&lt;AppState&gt;) {}\n\n    ngOnInit() {\n        this.todos$ = this.store.select((state) =&gt; state.todos);\n    }\n}</code></pre>\n      </div>\n<p>The framework will render the template every time <code class=\"language-text\">todos$</code> emits a new value.</p>\n<h3 id=\"when-does-not-not-make-sense-to-use-onpush\"><a href=\"#when-does-not-not-make-sense-to-use-onpush\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>When does not <em>not</em> make sense to use OnPush?</h3>\n<p>Never! OnPush is a simple way for making your applications <em>way</em> faster, and personally see no reasons for not using it every time.</p>\n<h2 id=\"refactoring-a-codebase-for-performance\"><a href=\"#refactoring-a-codebase-for-performance\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refactoring a codebase for performance</h2>\n<p>Most legacy Angular codebases I worked with were all using the default change detection, and the performance of the application was highly affected by that. Most developers were also not keen on the idea of using it, simply because it seems intimidating at first. But, well, it doesn't have to be.</p>\n<p>The first thing to know if you are planning on refactoring a codebase by also using the OnPush change detection, is that you never start from the parents.</p>","frontmatter":{"title":"Methods and practices for faster Angular apps - change detection","date":"14.04.2019","category":"angular"},"timeToRead":3}},"pageContext":{"slug":"/methods-and-practices-for-faster-angular-apps-change-detection","prev":null,"next":null}}